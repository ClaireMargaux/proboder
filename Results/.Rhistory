theme_minimal() +
ylab("count") +
xlab("time") +
ggtitle("Comparison of R")
# Plot for D
plot_D <- ggplot() +
geom_line(data = df, aes(x = t, y = D, color = "D"), linetype = "dotted") +
geom_line(data = df_X, aes(x = t, y = D, color = "D")) +
geom_ribbon(data = df_X, aes(x = t, ymin = ymin_D, ymax = ymax_D), fill = "lightgreen", alpha = 0.3) +
theme_minimal() +
ylab("count") +
xlab("time") +
ggtitle("Comparison of D")
# Arrange plots
library(gridExtra)
grid.arrange(plot_S, plot_I, plot_R, plot_D, nrow = 2)
# Plot of U
ggplot() +
geom_line(data = df_beta, aes(x = t, y = beta, color = "beta"), linetype = "dotted") +
geom_line(data = df_U, aes(x = t, y = beta, color = "beta")) +
geom_ribbon(data = df_U, aes(x = t, ymin = ymin_U, ymax = ymax_U), fill = "lightgreen", alpha = 0.3) +
theme_minimal() +
ylab("beta") +
xlab("time") +
ggtitle("Simulated and infered contact rate")
library(Matrix)
library(matrixcalc)
library(ggplot2)
library(numDeriv)
#####################################
############ SIMULATION #############
#####################################
# Time grid
steps <- 0.2
grid <- seq(0,8,by=steps)
n <- length(grid)
# Parameters
gamma <- 0.4
eta <- 0.2
pop <- 1000
parms  <- c(gamma = gamma, eta = eta, pop = pop)
# Beta
beta <- function(t){0.3*sin(t)+0.5}
beta_val <- beta(grid)
beta0 <- beta_val[1]
# Start values for steady state
y <- xstart <- c(S = 988, I = 10, R = 1, D = 1)
# ODE solver
library(deSolve)
SPCmod <- function(t, x, parms) {
with(as.list(c(parms, x)), {
beta <- beta(t)
dS <- - beta * S * I / pop
dI <- beta * S * I / pop - gamma * I - eta * I
dR <- gamma * I
dD <- eta * I
res <- c(dS, dI, dR, dD)
list(res)
})
}
# Solving
out <-  lsoda(xstart, grid, SPCmod, parms)
# Data frame
df <- data.frame(t <- grid, S <- out[,"S"], I <- out[,"I"], R <- out[,"R"], D <- out[,"D"])
colnames(df) <- c("t","S","I","R","D")
df_beta <- data.frame(t <- grid, beta_val <- beta_val)
# Plotting
countsplot <- ggplot(df, aes(x = t, y = S)) +
geom_line(aes(color = 'S')) +
geom_line(aes(x = t, y = I, color = 'I')) +
geom_line(aes(x = t, y = R, color = 'R')) +
geom_line(aes(x = t, y = D, color = 'D')) +
theme_minimal() +
scale_y_continuous(trans='log10') +
ylab("log(count)") +
xlab("time") +
ggtitle("LSODA")
betaplot <- ggplot(df_beta, aes(x = t, y = beta_val)) +
geom_line(aes(color = 'beta')) +
theme_minimal() +
ylab("beta") +
xlab("time") +
ggtitle("Simulated beta")
countsplot
betaplot
# ODE
f <- function(X, beta){
dS <- - beta * X[1] * X[2] / pop
dI <- beta * X[1] * X[2] / pop - gamma * X[2] - eta * X[2]
dR <- gamma * X[2]
dD <- eta * X[2]
res <- c(dS, dI, dR, dD)
return(res)
}
f0 <- function(X){
dS <- - beta0 * X[1] * X[2] / pop
dI <- beta0 * X[1] * X[2] / pop - gamma * X[2] - eta * X[2]
dR <- gamma * X[2]
dD <- eta * X[2]
res <- c(dS, dI, dR, dD)
return(res)
}
h <- function(X, U) {
beta <- U[1]
beta <- sigmoid(beta) # rescaling of beta to [0,1]
X0 <- X[1:4]
X1 <- X[5:8]
ODE <- f(X0, beta)
sol <- c(X1 - ODE)
return(sol)
}
jacobian_h <- function(X, U) {
h1 <- function(x) h(x, U = U)
h2 <- function(u) h(X = X, u)
out <- cbind(jacobian(h1, x = X), jacobian(h2, x = U))
return(out)
}
# Sigmoid and logit functions
sigmoid <- function(z) {
return(1 / (1 + exp(-z)))
}
logit <- function(p) {
return(log(p / (1 - p)))
}
# Initialization
X0 <- c(df[1,2], df[1,3], df[1,4], df[1,5]) # Initial values for S, I, R and D
X1 <- f0(X0) # Initial values for 1st derivatives
X2 <- diag(jacobian(f0, x = X0)) # Initial values for 2nd derivatives
P_X <- diag(0, nrow = 12, ncol = 12)
P_U <- diag(0, nrow = 2, ncol = 2)
U0 <- logit(beta0)
U1 <- 4
X <- matrix(data = NA, nrow = 12, ncol = n)
X[, 1] <- as.vector(c(X0,X1,X2))
covX <- array(data = NA, dim = c(12, 12, n))
covX[, , 1] <- P_X
U <- matrix(data = NA, nrow = 2, ncol = n)
U[, 1] <- c(U0,U1)
covU <- array(data = NA, dim = c(2, 2, n))
covU[, , 1] <- P_U
# Observation model ODE
H <- as.matrix(sparseMatrix(i = 1:4, j = 5:8, x = 1, dims = c(4,14)))
# Observation model OBS
Hobs <- as.matrix(sparseMatrix(i = 1:4, j = 1:4, x = 1, dims = c(4,14)))
# Observations with noise
y <- df[,2:5]
noise <- 0.01
y_with_noise <- y + matrix(rnorm(n*n, mean = 0, sd = sqrt(noise)), nrow = n)
R <- diag(noise, nrow = 4, ncol = 4)
# Drift matrix
lengthscale <- 1.2
drift <- as.matrix(sparseMatrix(i = 1:8, j = 5:12, x = 1, dims = c(12,12)))
drift_U <- matrix(c(0,-(sqrt(3)/lengthscale)^2,1,-2*sqrt(3)/lengthscale), nrow = 2, ncol = 2)
# Dispersion matrix
dispersion <- as.matrix(sparseMatrix(i = 9:12, j = 1:4, x = 1, dims = c(12,4)))
dispersion_U <- matrix(c(0,1), nrow = 2, ncol = 1)
# Noise Wiener process
noise_wiener <- diag(100, nrow = ncol(dispersion), ncol = ncol(dispersion))
noise_wiener_U <- diag(20, nrow = ncol(dispersion_U), ncol = ncol(dispersion_U))
# Transition matrices
Ad <- expm(steps*drift)
l <- nrow(drift)
top_row <- cbind(steps*drift, steps*dispersion %*% noise_wiener %*% t(dispersion))
bottom_row <- cbind(matrix(0, nrow = l, ncol = l), -steps*t(drift))
Gamma <- rbind(top_row, bottom_row)
exp_Gamma <- expm(Gamma)
M_1 <- exp_Gamma[1:l, 1:l]
M_2 <- exp_Gamma[1:l, (l + 1):(2 * l)]
M_3 <- exp_Gamma[(l + 1):(2 * l), (l + 1):(2 * l)]
Qd <- M_2 %*% t(M_1)
Ad_U <- expm(steps*drift_U)
l <- nrow(drift_U)
top_row <- cbind(steps*drift_U, steps*dispersion_U %*% noise_wiener_U %*% t(dispersion_U))
bottom_row <- cbind(matrix(0, nrow = l, ncol = l), -steps*t(drift_U))
Gamma <- rbind(top_row, bottom_row)
exp_Gamma <- expm(Gamma)
M_1 <- exp_Gamma[1:l, 1:l]
M_2 <- exp_Gamma[1:l, (l + 1):(2 * l)]
M_3 <- exp_Gamma[(l + 1):(2 * l), (l + 1):(2 * l)]
Qd_U <- M_2 %*% t(M_1)
# Prediction function
prediction <- function(m, P, A, Q){
m_out <- as.matrix(A %*% m)
P_out <- as.matrix(A %*% P %*% t(A) + Q)
return(list(m_out,P_out))
}
# Update function ODE
update_ODE <- function(m, P, f, H, beta, J){
y <- f(m, beta)
v <- y - H %*% m # residual
#R <- 0 # no noise
R <- J %*% P %*% t(J) # with noise
S <- H %*% P %*% t(H) + R # innovation covariance
S_inv <- solve(S)
K <- P %*% t(H) %*% S_inv # Kalman gain
m_out <- m + K %*% v # updated mean
P_out <- P - K %*% S %*% t(K) # updated covariance
return(list(m_out,P_out))
}
update_of_states <- function(m, P, h, J) {
v <- - h # residual
S <- J %*% P %*% t(J) # innovation covariance
S_inv <- svd.inverse(S)
K <- P %*% t(J) %*% S_inv # Kalman gain
m_out <- m + K %*% v # updated mean
P_out <- P - K %*% S %*% t(K) # updated covariance
return(list(m_out = m_out, P_out = P_out))
}
# Update function observations
update_obs <- function(m, P, y, H, R){
v <- y - H %*% m # residual
S <- H %*% P %*% t(H) + R # innovation covariance
S_inv <- svd.inverse(S)
K <- P %*% t(H) %*% S_inv # Kalman gain
m_out <- m + K %*% t(v) # updated mean
P_out <- P - K %*% S %*% t(K) # updated covariance
out <- list(m_out,P_out)
return(list(m_out,P_out))
}
matrix_P <- function(P_U, P_X) {
P_U <- as.matrix(P_U)
P_X <- as.matrix(P_X)
ncol_P <- ncol(P_X) + ncol(P_U)
nrow_P <- nrow(P_X) + nrow(P_U)
P <- matrix(0, nrow = nrow_P, ncol = ncol_P)
P[1:nrow(P_U), 1:ncol(P_U)] <- P_U  # Top left corner
P[(nrow_P - nrow(P_X) + 1):nrow_P, (ncol_P - ncol(P_X) + 1):ncol_P] <- P_X  # Bottom right corner
return(P)
}
# Inference
for(i in 2:n){
X_prev <- as.matrix(X[,i-1])
covX_prev <- as.matrix(covX[,,i-1])
U_prev <- as.matrix(U[,i-1])
covU_prev <- as.matrix(covU[,,i-1])
prediction_result <- prediction(X_prev,covX_prev, Ad, Qd)
X_pred <- prediction_result[[1]]
covX_pred <- prediction_result[[2]]
prediction_result_U <- prediction(U_prev,covU_prev, Ad_U, Qd_U)
U_pred <- prediction_result_U[[1]]
covU_pred <- prediction_result_U[[2]]
beta <- sigmoid(U_pred[1])
m <- c(X_pred, U_pred)
P <- matrix_P(covX_pred, covU_pred)
hval <- h(X_pred,U_pred)
Jval <- jacobian_h(X_pred, U_pred)
#update_result_ODE <- update_ODE(m, P, f, H, beta, Jval)
update_result_ODE <- update_of_states(m, P, hval, Jval)
X_update <- (update_result_ODE[[1]][1:12])
U_update <- (update_result_ODE[[1]][13:14])
covX_update <- (update_result_ODE[[2]][1:12, 1:12])
covU_update <- (update_result_ODE[[2]][13:14, 13:14])
y <- y_with_noise[i,]
m <- c(X_update, U_update)
P <- matrix_P(covX_update, covU_update)
update_result_obs <- update_obs(m, P, y, Hobs, R)
X_update <- (update_result_obs[[1]][1:12])
U_update <- (update_result_obs[[1]][13:14])
covX_update <- (update_result_obs[[2]][1:12, 1:12])
covU_update <- (update_result_obs[[2]][13:14, 13:14])
X[,i] <- X_update
covX[,,i] <- covX_update
U[,i] <- U_update
covU[,,i] <- covU_update
}
df_covX <- covX[1:4,1:4,]
df_covU <- covU[1,1,]
df_X <- data.frame(t = grid, X = t(X[1:4,]))
df_U <- data.frame(t = grid, U = sigmoid(U[1,]))
colnames(df_X) <- c("t","S","I","R","D")
colnames(df_U) <- c("t","beta")
df_beta <- data.frame(t = grid, beta = beta_val)
calculate_y_bounds <- function(X, P_X, sigma) {
ymin <- mapply(function(mu, sigma) (qnorm(0.025, mean = mu, sd = sqrt(sigma))), X, P_X)
ymax <- mapply(function(mu, sigma) (qnorm(0.975, mean = mu, sd = sqrt(sigma))), X, P_X)
return(list(ymin = ymin, ymax = ymax))
}
ymin_S <- calculate_y_bounds(df_X$S,df_covX[1,1,])[[1]]
ymax_S <- calculate_y_bounds(df_X$S,df_covX[1,1,])[[2]]
ymin_I <- calculate_y_bounds(df_X$I,df_covX[2,2,])[[1]]
ymax_I <- calculate_y_bounds(df_X$I,df_covX[2,2,])[[2]]
ymin_R <- calculate_y_bounds(df_X$R,df_covX[3,3,])[[1]]
ymax_R <- calculate_y_bounds(df_X$R,df_covX[3,3,])[[2]]
ymin_D <- calculate_y_bounds(df_X$D,df_covX[4,4,])[[1]]
ymax_D <- calculate_y_bounds(df_X$D,df_covX[4,4,])[[2]]
minmax <- data.frame(
ymin_S = ymin_S,
ymax_S = ymax_S,
ymin_I = ymin_I,
ymax_I = ymax_I,
ymin_R = ymin_R,
ymax_R = ymax_R,
ymin_D = ymin_D,
ymax_D = ymax_D
)
df_X <- cbind(df_X,minmax)
ymin_U <- mapply(function(mu, sigma) sigmoid(qnorm(0.025, mean = mu, sd = sqrt(sigma))), U[1,], covU[1,1,])
ymax_U <- mapply(function(mu, sigma) sigmoid(qnorm(0.975, mean = mu, sd = sqrt(sigma))), U[1,], covU[1,1,])
df_U <- cbind(df_U,ymin_U,ymax_U)
# Plotting
ggplot() +
geom_line(data = df, aes(x = t, y = S, color = "S"), linetype = "dotted") +
geom_line(data = df, aes(x = t, y = I, color = "I"), linetype = "dotted") +
geom_line(data = df, aes(x = t, y = R, color = "R"), linetype = "dotted") +
geom_line(data = df, aes(x = t, y = D, color = "D"), linetype = "dotted") +
geom_line(data = df_X, aes(x = t, y = S, color = "S")) +
geom_line(data = df_X, aes(x = t, y = I, color = "I")) +
geom_line(data = df_X, aes(x = t, y = R, color = "R")) +
geom_line(data = df_X, aes(x = t, y = D, color = "D")) +
theme_minimal() +
scale_y_continuous(trans = 'log10') +
ylab("log(count)") +
xlab("time") +
ggtitle("LSODA and inference")
# Plot for S
plot_S <- ggplot() +
geom_line(data = df, aes(x = t, y = S, color = "S"), linetype = "dotted") +
geom_line(data = df_X, aes(x = t, y = S, color = "S")) +
geom_ribbon(data = df_X, aes(x = t, ymin = ymin_S, ymax = ymax_S), fill = "lightgreen", alpha = 0.3) +
theme_minimal() +
ylab("count") +
xlab("time") +
ggtitle("Comparison of S")
# Plot for I
plot_I <- ggplot() +
geom_line(data = df, aes(x = t, y = I, color = "I"), linetype = "dotted") +
geom_line(data = df_X, aes(x = t, y = I, color = "I")) +
geom_ribbon(data = df_X, aes(x = t, ymin = ymin_I, ymax = ymax_I), fill = "lightgreen", alpha = 0.3) +
theme_minimal() +
ylab("count") +
xlab("time") +
ggtitle("Comparison of I")
# Plot for R
plot_R <- ggplot() +
geom_line(data = df, aes(x = t, y = R, color = "R"), linetype = "dotted") +
geom_line(data = df_X, aes(x = t, y = R, color = "R")) +
geom_ribbon(data = df_X, aes(x = t, ymin = ymin_R, ymax = ymax_R), fill = "lightgreen", alpha = 0.3) +
theme_minimal() +
ylab("count") +
xlab("time") +
ggtitle("Comparison of R")
# Plot for D
plot_D <- ggplot() +
geom_line(data = df, aes(x = t, y = D, color = "D"), linetype = "dotted") +
geom_line(data = df_X, aes(x = t, y = D, color = "D")) +
geom_ribbon(data = df_X, aes(x = t, ymin = ymin_D, ymax = ymax_D), fill = "lightgreen", alpha = 0.3) +
theme_minimal() +
ylab("count") +
xlab("time") +
ggtitle("Comparison of D")
# Arrange plots
library(gridExtra)
grid.arrange(plot_S, plot_I, plot_R, plot_D, nrow = 2)
# Plot of U
ggplot() +
geom_line(data = df_beta, aes(x = t, y = beta, color = "beta"), linetype = "dotted") +
geom_line(data = df_U, aes(x = t, y = beta, color = "beta")) +
geom_ribbon(data = df_U, aes(x = t, ymin = ymin_U, ymax = ymax_U), fill = "lightgreen", alpha = 0.3) +
theme_minimal() +
ylab("beta") +
xlab("time") +
ggtitle("Simulated and infered contact rate")
#' Plot Simulated Contact Rate
#'
#' This function generates a plot of the simulated contact rate
#'
#' @param real_beta_df Data frame containing the real contact rate values (optional).
#' @param latency_rate Numeric value indicating the latency rate.
#' @param recovery_rate Numeric value indicating the recovery rate.
#' @param fatality_rate Numeric value indicating the fatality rate.
#' @return A ggplot object displaying the contact rate plot.
#' @export
plot_sim_contact_rate <- function(real_beta_df = NULL, latency_rate, recovery_rate, fatality_rate) {
ggplot() +
geom_line(data = real_beta_df, aes(x = time, y = real_beta, color = "Simulated contact rate"), linetype = "dashed") +
labs(x = "Time", y = "Simulated contact rate", title = "Simulated contact rate",
color = "Legend") +
scale_color_manual(values = c("Simulated contact rate" = "#E69F00"),
labels = c("Simulated contact rate"), name = "Lines") +
theme_minimal() +
theme(legend.position = "top") +
guides(color = guide_legend(order = 1)) +
annotate("text", x = min(U_plot$time), y = min(U_scaled), label = paste("Latency Rate:", latency_rate), hjust = 0, vjust = -3, size = 3) +
annotate("text", x = min(U_plot$time), y = min(U_scaled), label = paste("Recovery Rate:", recovery_rate), hjust = 0, vjust = -1, size = 3) +
annotate("text", x = min(U_plot$time), y = min(U_scaled), label = paste("Fatality Rate:", fatality_rate), hjust = 0, vjust = 1, size = 3)
}
# Plot contact rate
plot_sim_contact_rate(real_beta_df, latency_rate, recovery_rate, fatality_rate)
#####################################
############# WORKFLOW ##############
#####################################
# Import functions
source('~/Documents/GitHub/proboder/initialization.R')
source('~/Documents/GitHub/proboder/functions_for_inference.R')
source('~/Documents/GitHub/proboder/saving_loading_plotting.R')
# Necessary packages
library(Matrix) # for sparseMatrix() and expm()
library(numDeriv) # for jacobian()
library(matrixcalc) # for svd.inverse()
library(ggplot2) # for ggplot()
# Choose data to be imported
type <- 'simulated_LSODA' # set 'real' for real data, 'simulated_LSODA' for simulated data using LSODA, and 'simulated_HETTMO' for simulated data using HETTMO
region <- 'BE' # 'BE' or 'GE' available (if 'real' data selected)
daily_or_weekly <- 'weekly' # choose either 'daily' or 'weekly' (if 'real' data selected)
if(type == 'simulated_LSODA'){
directory_data <- "~/Documents/GitHub/proboder/Data/LSODA" # directory of data
}else if(type == 'simulated_HETTMO'){
directory_data <- "~/Documents/GitHub/proboder/Data/HETTMO" # directory of data
}else if(type == 'real'){
directory_data <- "~/Documents/GitHub/proboder/Data/real" # directory of data
}
# Import data
data <- load_data(type,region,daily_or_weekly,directory_data)
obs <- data$obs
obs_with_noise <- data$obs_with_noise
params <- data$params
if(type != 'real'){
real_beta <- data$real_beta
}
# Sanity check.
head(obs)
#####################################
########## INITIALIZATION ###########
#####################################
# If using data simulated with LSODA:
# lambda = 0.6, gamma = 0.4, eta = 0.2, noise_obs = 0.1
# beta0 = 0.5, beta0prime = 0.3
# pop = 1000
initial_params <-
initialization(obs_with_noise, beta0 = 0.5, beta0prime = 0.3,
lambda = 0.6, gamma = 0.4, eta = 0.2,
l = 1.2, scale = 1, noise_obs = 0.1,
noise_wiener_X = 100, noise_wiener_U = 10,
pop = 1000)
# If using data simulated with HETTMO:
# lambda = 0.3703704, gamma = 0.3703704, eta = 0
# pop = 1e+05
# initial_params <-
#   initialization(obs, beta0 = 0.9721224, beta0prime = -1.5,
#                  lambda = 0.3703704, gamma = 0.3703704, eta = 0,
#                  l = 1.2, scale = 3, noise_obs = 100,
#                  noise_wiener_X = 1e+03, noise_wiener_U = 0.1,
#                  pop = 1e+05)
#####################################
############# ALGORITHM #############
#####################################
# Data grid
data_grid <- obs[,'t']
# ODE grid
ode_grid <- data_grid # no more points than observations
# Adding more points than observations
#num_points_between <- 2
#for (i in 1:(length(data_grid) - 1)) {
# Generate equidistant points between the current and next data point
#equidistant_points <- seq(data_grid[i], data_grid[i + 1], length.out = num_points_between + 2)[-c(1, num_points_between + 2)]
# Append the equidistant points to the ODE grid
#ode_grid <- c(ode_grid, equidistant_points)
#}
# Overall time grid
time_grid <- sort(unique(c(data_grid, ode_grid)))
# Time steps
steps <- ode_grid[2]-ode_grid[1]
# Run inference
inference_results <- inference(time_grid, data_grid, ode_grid, steps, obs, initial_params)
X_values <- inference_results$X_values
U_values <- inference_results$U_values
P_X_values <- inference_results$P_X_values
P_U_values <- inference_results$P_U_values
# ------------
# Save results
# ------------
# Specify directory for results
directory_res = "~/Documents/GitHub/proboder/Results"
# Save results to the specified directory
save_results_as_Rdata(X_values, U_values, P_X_values, P_U_values, directory_res)
#####################################
########### VISUALIZATION ###########
#####################################
# ---------------------
# Extract relevant data
# ---------------------
# Load and process data from the specified directory
processed_data <- load_and_process_data(directory_res,time_grid)
U_plot <- processed_data$U_plot
P_plot <- processed_data$P_plot
ymin <- P_plot$ymin
ymax <- P_plot$ymax
U_scaled <- processed_data$U_scaled
Xval <- processed_data$Xval
# Save processed data to the specified directory
save_processed_data(U_plot, P_plot, ymin, ymax, U_scaled, Xval, directory_res)
# Create data frame for real beta values (if available)
if(type!='real'){
real_beta_df <- data.frame(time = data_grid, real_beta = real_beta)
}
# --------
# Plotting
# --------
setwd(directory_res)
# Plot data
pdf("SIR-counts.pdf", width = 8, height = 6)
plot_data_sim(obs,obs_with_noise,Xval)
dev.off()
plot_data_sim(obs,obs_with_noise,Xval)
lambda <- initial_params$lambda
gamma <- initial_params$gamma
eta <- initial_params$eta
l <- initial_params$l
# Plot contact rate
plot_sim_contact_rate(real_beta_df, latency_rate, recovery_rate, fatality_rate)
# Plot contact rate
plot_sim_contact_rate(real_beta_df, lambda, gamma, eta)
