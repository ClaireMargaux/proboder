---
title: "Workflow ProbODER Simulated data"
author: "Claire Descombes"
date: "`r Sys.Date()`"
output: 
  html_document:
    css: styles.css
    self_contained: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=8, fig.height=6)
```

## Import packages

#### Import
```{r, echo=FALSE, include=FALSE}
# Set source directory
source_directory <- '~/Documents/GitHub/proboder/Functions/'

# Source necessary functions
source(file.path(source_directory, 'LSODA.R'))
source(file.path(source_directory, 'initialization.R'))
source(file.path(source_directory, 'inference.R'))
source(file.path(source_directory, 'processing_saving_loading.R'))
source(file.path(source_directory, 'scoring.R'))
source(file.path(source_directory, 'plotting.R'))
source(file.path(source_directory, 'random_search.R'))

# Load or install necessary packages
load_required_packages()
```





#-------------------------------------------------------------------------------

## Simulation Example (simEx)

#### Simulate data

```{r, fig.width=8, fig.height=6}
# ------------------------
# Simulation of a data set
# ------------------------

model <- 'SEIR' # model to be simulated 
                # ('SEIRD' or 'SEIR' available)

steps <- 1 # steps for time grid
max_time <- 30 # max time for time grid

lambda <- 1/(2.6) # latency rate, ref value 1/(2.6)
gamma <- 1/(2.6) # recovery rate, ref value 1/(2.6)
if (model == 'SEIRD') {
  eta <- 0.024*(1/15) # fatality rate, ref value 0.024*(1/15)
} else if (model == 'SEIR') {
  eta <- 0
}

beta <- function(t){2*cos(t/30)-1} # function for transmission rate

# Starting compartment counts
if (model == 'SEIRD') {
  xstart <- c(S = 499980, E = 5, I = 5, R = 5, D = 5)
} else if (model == 'SEIR') {
  xstart <- c(S = 499985, E = 5, I = 5, R = 5)
}
pop <- sum(xstart)

noise_obs <- 10 # noise to add on the data
            # set > 0 to avoid numerical instabilities
seed <- 5 # any integer, for reproducibility 
          # (set NA for no seed)

# Data simulation
sim <- simulate_data_LSODA(
    model = model,
    noise = noise_obs,
    seed = seed,
    steps = steps,
    max_time = max_time,
    lambda = lambda, gamma = gamma, eta = eta,
    pop = pop, 
    beta = beta,
    xstart = xstart)

# Get simulated data sets
obs <- sim$obs
df_beta <- sim$df_beta
df_R <- sim$df_R
if (noise_obs > 0) {
  obs_with_noise <- sim$obs_with_noise
}
obs_with_noise_only_R <- 
  obs_with_noise %>% select(t, R)

# Visualization
plots <- plotting_simulated_data_lsoda(
  model = model,
  sim = sim,
  latency_rate = lambda,
  recovery_rate = gamma,
  fatality_rate = eta,
  log = TRUE)

(simulated_beta <- plots$simulated_beta)
(simulated_R <- plots$simulated_R)
(simulated_compartments <- plots$simulated_compartments)
(simulated_compartments_except_S <- plots$simulated_compartments_except_S)
```

#### Perform inference

```{r, fig.width=8, fig.height=6}
# ---------
# Inference
# ---------

l <- 15 # lengthscale
noise_wiener_X <- 10 # noise of Wiener process associated with X
noise_wiener_U <- 0.01 # noise of Wiener process associated with U
beta0 = df_beta$beta[1] # starting transmission rate
beta0prime <- 0 # starting 1st derivative of transmission rate
jit <- 1e-5 # value for jitter on innovation covariance
obs_to_use <- obs_with_noise # choose if obs, obs_with_noise,        
                             # obs_with_noise_only_R

# Initialize
initial_params <-
    initialization(model = model, obs = obs_to_use,
                   beta0 = beta0, beta0prime = beta0prime,
                   lambda = lambda, gamma = gamma, eta = eta,
                   l = l, scale = 1, noise_obs = noise_obs,
                   noise_X = sqrt(noise_obs), noise_U = 0.2,
                   noise_wiener_X = noise_wiener_X, 
                   noise_wiener_U = noise_wiener_U,
                   pop = pop,
                   start_S = NULL, start_E = NULL, 
                   start_I = NULL, start_R = NULL,
                   start_D = NULL)

# Generate time grids for inference
grids <- generate_grid(obs, num_points_between = 0)

# Run inference
inference_results <- inference(model = model, 
                               grids = grids, 
                               obs = obs_to_use, 
                               jit = jit, 
                               initial_params = initial_params)

# Process data for scoring and visualization
processed_data <- process_data(inference_results = inference_results,
                               grids = grids,
                               model = model,
                               pop = pop, 
                               lambda = lambda, 
                               gamma = gamma, 
                               eta = eta)
U_plot <- processed_data$U_plot
X_plot <- processed_data$X_plot
R_plot <- processed_data$R_plot
cond_plot <- processed_data$cond_plot

# Compute and display scores
list_of_scores <- 
    compute_scores_and_table(U_plot = U_plot, df_beta = df_beta)
(scores_table <- list_of_scores$scores_table)

# Plot compartment counts inferred from simulated data
(compartments <- 
  plot_compartments(model = model,
     obs = obs, 
     obs_with_noise = obs_with_noise, # if available, otherwise set NULL
     X_plot = X_plot))

# Plot all but S compartment counts inferred from simulated data
(compartments_except_S <- 
  plot_compartments_except_S(
    model = model,
    obs = obs, 
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot))

# Plot compartment counts separately
plots_sep <- 
  plot_compartments_separately(
    model = model,
    obs = obs,
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot)

num_plots <- length(plots_sep)
invisible(grid_plots_sep <- grid.arrange(
    grobs = plots_sep,
    ncol = 2,
    nrow = ceiling(num_plots/2)))

# Plot transmission rate with 95% confidence interval
(transmission_rate_with_CI <- 
    plot_transmission_rate_with_CI(U_plot = U_plot, 
    df_beta = df_beta, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot reproduction number with approx. 95% confidence interval
(reproduction_number_with_CI <- 
    plot_reproduction_number_with_CI(R_plot = R_plot, 
    df_R = df_R, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot condition numbers of the innovation covariances 
# and covariance matrices
cond_plots <- 
    plot_condition_numbers(cond_plot)

number_plots <- length(cond_plots)
invisible(condition_numbers <- grid.arrange(
    grobs = cond_plots,
    ncol = 2,
    nrow = ceiling(number_plots/2)))
```

#### Perform random search 

```{r, fig.width=8, fig.height=6}
# -------------
# Random search
# -------------

if (FALSE) { # set TRUE to perform random search
  seed <- 5
  num_param_sets <- 1000 # number of parameter sets to sample

  seq_l <- seq(1, 100, by = 1)
  seq_wiener_X <- c(0.001, 0.01, 0.1, 1, 10, 100)
  seq_wiener_U <- seq(0.001, 1, by = 0.01)
  seq_beta0prime <- c(-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1)
  seq_jit <- c(1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1)
  
  # seq_l <- 15
  # seq_wiener_X <- exp(seq(-7,7,length.out=100))
  # seq_wiener_U <- 0.01
  # seq_beta0prime <- 0
  # seq_jit <- 1e-5
  
  results_summary <- 
    run_random_search(
      model = model, obs_to_use = obs_to_use, df_beta = df_beta, 
      noise_obs = noise_obs, 
      lambda = lambda, gamma = gamma, eta = eta, pop = pop, 
      beta0 = beta0, 
      seed = seed, num_param_sets = num_param_sets, 
      seq_l = seq_l, 
      seq_wiener_X = seq_wiener_X, 
      seq_wiener_U = seq_wiener_U, 
      seq_beta0prime = seq_beta0prime,
      seq_jit = seq_jit
  )
}

# Number of warnings encountered: 0
# Duration of the whole workflow: 87.073 sec elapsed

# Plot the mean scores for all hyperparameter sets explored
plots_scores <- plot_scores(
  results_summary, 
  aggregate = FALSE # if TRUE, plots reflect aggregated scores
)
invisible(grid_of_mean_plots <- grid.arrange(
  grobs = plots_scores$mean_plots,
  ncol = 2, 
  nrow = 3))
plots_scores_agg <- plot_scores(
  results_summary, 
  aggregate = TRUE # if TRUE, plots reflect aggregated scores
)
invisible(grid_of_mean_plots_agg <- grid.arrange(
  grobs = plots_scores_agg$mean_plots,
  ncol = 2, 
  nrow = 3))

# Generate a table displaying the best mean CRPS, NLPD, and SPE
best_parameters <- find_best_hyperparameters(results_summary)
(best_params_table <- best_parameters$best_params_table)

# Plot the scores (CRPS, NLPD, SPE) for each hyperparameter set
# that performed best in one of the mean scores (CRPS, NLPD, SPE).
best_scores_output <- 
  scores_of_best_params(
    best_parameters = best_parameters, 
    model = model, 
    obs_to_use = obs_to_use, 
    df_beta = df_beta, 
    noise_obs = noise_obs, 
    lambda = lambda, gamma = gamma, eta = eta, 
    pop = pop, 
    seed = seed)
invisible(best_scores_plot <- grid.arrange(
  grobs = best_scores_output$best_scores_plot,
  ncol = 1, 
  nrow = 3))

# Note that the random search runs even if errors are raised. 
# The number of errors is given at the end of the search.
```

#### Perform inference using hyperparameters with best mean CRPS/NLPD

```{r, fig.width=8, fig.height=6}
# ---------
# Inference
# ---------

l <- 3 # lengthscale
noise_wiener_X <- 1 # noise of Wiener process associated with X
noise_wiener_U <- 0.561 # noise of Wiener process associated with U
beta0prime <- 0.75 # starting 1st derivative of transmission rate
jit <- 1e-4 # value for jitter on innovation covariance

# Initialize
initial_params <-
    initialization(model = model, obs = obs_to_use,
                   beta0 = beta0, beta0prime = beta0prime,
                   lambda = lambda, gamma = gamma, eta = eta,
                   l = l, scale = 1, noise_obs = noise_obs,
                   noise_X = sqrt(noise_obs), noise_U = 0.2,
                   noise_wiener_X = noise_wiener_X, 
                   noise_wiener_U = noise_wiener_U,
                   pop = pop,
                   start_S = NULL, start_E = NULL, 
                   start_I = NULL, start_R = NULL,
                   start_D = NULL)

# Generate time grids for inference
grids <- generate_grid(obs, num_points_between = 0)

# Run inference
inference_results <- inference(model = model, 
                               grids = grids, 
                               obs = obs_to_use, 
                               jit = jit, 
                               initial_params = initial_params)

# Process data for scoring and visualization
processed_data <- process_data(inference_results = inference_results,
                               grids = grids,
                               model = model,
                               pop = pop, 
                               lambda = lambda, 
                               gamma = gamma, 
                               eta = eta)
U_plot <- processed_data$U_plot
X_plot <- processed_data$X_plot
R_plot <- processed_data$R_plot
cond_plot <- processed_data$cond_plot

# Compute and display scores
list_of_scores <- 
    compute_scores_and_table(U_plot = U_plot, df_beta = df_beta)
(scores_table <- list_of_scores$scores_table)

# Plot compartment counts inferred from simulated data
(compartments <- 
  plot_compartments(model = model,
     obs = obs, 
     obs_with_noise = obs_with_noise, # if available, otherwise set NULL
     X_plot = X_plot))

# Plot all but S compartment counts inferred from simulated data
(compartments_except_S <- 
  plot_compartments_except_S(
    model = model,
    obs = obs, 
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot))

# Plot compartment counts separately
plots_sep <- 
  plot_compartments_separately(
    model = model,
    obs = obs,
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot)

num_plots <- length(plots_sep)
invisible(grid_plots_sep <- grid.arrange(
    grobs = plots_sep,
    ncol = 2,
    nrow = ceiling(num_plots/2)))

# Plot transmission rate with 95% confidence interval
(transmission_rate_with_CI <- 
    plot_transmission_rate_with_CI(U_plot = U_plot, 
    df_beta = df_beta, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot reproduction number with approx. 95% confidence interval
(reproduction_number_with_CI <- 
    plot_reproduction_number_with_CI(R_plot = R_plot, 
    df_R = df_R, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot condition numbers of the innovation covariances 
# and covariance matrices
cond_plots <- 
    plot_condition_numbers(cond_plot)

number_plots <- length(cond_plots)
invisible(condition_numbers <- grid.arrange(
    grobs = cond_plots,
    ncol = 2,
    nrow = ceiling(number_plots/2)))
```











#### Perform inference using hyperparameters with best mean SPE

```{r, fig.width=8, fig.height=6}
# ---------
# Inference
# ---------

l <- 8 # lengthscale
noise_wiener_X <- 1 # noise of Wiener process associated with X
noise_wiener_U <- 0.081 # noise of Wiener process associated with U
beta0prime <- 0.25 # starting 1st derivative of transmission rate
jit <- 1 # value for jitter on innovation covariance

# Initialize
initial_params <-
    initialization(model = model, obs = obs_to_use,
                   beta0 = beta0, beta0prime = beta0prime,
                   lambda = lambda, gamma = gamma, eta = eta,
                   l = l, scale = 1, noise_obs = noise_obs,
                   noise_X = sqrt(noise_obs), noise_U = 0.2,
                   noise_wiener_X = noise_wiener_X, 
                   noise_wiener_U = noise_wiener_U,
                   pop = pop,
                   start_S = NULL, start_E = NULL, 
                   start_I = NULL, start_R = NULL,
                   start_D = NULL)

# Generate time grids for inference
grids <- generate_grid(obs, num_points_between = 0)

# Run inference
inference_results <- inference(model = model, 
                               grids = grids, 
                               obs = obs_to_use, 
                               jit = jit, 
                               initial_params = initial_params)

# Process data for scoring and visualization
processed_data <- process_data(inference_results = inference_results,
                               grids = grids,
                               model = model,
                               pop = pop, 
                               lambda = lambda, 
                               gamma = gamma, 
                               eta = eta)
U_plot <- processed_data$U_plot
X_plot <- processed_data$X_plot
R_plot <- processed_data$R_plot
cond_plot <- processed_data$cond_plot

# Compute and display scores
list_of_scores <- 
    compute_scores_and_table(U_plot = U_plot, df_beta = df_beta)
(scores_table <- list_of_scores$scores_table)

# Plot compartment counts inferred from simulated data
(compartments <- 
  plot_compartments(model = model,
     obs = obs, 
     obs_with_noise = obs_with_noise, # if available, otherwise set NULL
     X_plot = X_plot))

# Plot all but S compartment counts inferred from simulated data
(compartments_except_S <- 
  plot_compartments_except_S(
    model = model,
    obs = obs, 
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot))

# Plot compartment counts separately
plots_sep <- 
  plot_compartments_separately(
    model = model,
    obs = obs,
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot)

num_plots <- length(plots_sep)
invisible(grid_plots_sep <- grid.arrange(
    grobs = plots_sep,
    ncol = 2,
    nrow = ceiling(num_plots/2)))

# Plot transmission rate with 95% confidence interval
(transmission_rate_with_CI <- 
    plot_transmission_rate_with_CI(U_plot = U_plot, 
    df_beta = df_beta, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot reproduction number with approx. 95% confidence interval
(reproduction_number_with_CI <- 
    plot_reproduction_number_with_CI(R_plot = R_plot, 
    df_R = df_R, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot condition numbers of the innovation covariances 
# and covariance matrices
cond_plots <- 
    plot_condition_numbers(cond_plot)

number_plots <- length(cond_plots)
invisible(condition_numbers <- grid.arrange(
    grobs = cond_plots,
    ncol = 2,
    nrow = ceiling(number_plots/2)))
```












#-------------------------------------------------------------------------------

## Simulation A (simA)

With D compartment.

#### Simulate data

```{r, fig.width=8, fig.height=6}
# ------------------------
# Simulation of a data set
# ------------------------

model <- 'SEIRD' # model to be simulated 
                 # ('SEIRD' or 'SEIR' available)

steps <- 1 # steps for time grid
max_time <- 30 # max time for time grid

lambda <- 1/(2.6) # latency rate, ref value 1/(2.6)
gamma <- 1/(2.6) # recovery rate, ref value 1/(2.6)
if (model == 'SEIRD') {
  eta <- 0.024*(1/15) # fatality rate, ref value 0.024*(1/15)
} else if (model == 'SEIR') {
  eta <- 0
}

beta <- function(t){2*cos(t/30)-1} # function for transmission rate

# Starting compartment counts
if (model == 'SEIRD') {
  xstart <- c(S = 499980, E = 5, I = 5, R = 5, D = 5)
} else if (model == 'SEIR') {
  xstart <- c(S = 499985, E = 5, I = 5, R = 5)
}
pop <- sum(xstart)

noise_obs <- 10 # noise to add on the data
            # set > 0 to avoid numerical instabilities
seed <- 5 # any integer, for reproducibility 
          # (set NA for no seed)

# Data simulation
sim <- simulate_data_LSODA(
    model = model,
    noise = noise_obs,
    seed = seed,
    steps = steps,
    max_time = max_time,
    lambda = lambda, gamma = gamma, eta = eta,
    pop = pop, 
    beta = beta,
    xstart = xstart)

# Get simulated data sets
obs <- sim$obs
df_beta <- sim$df_beta
df_R <- sim$df_R
if (noise_obs > 0) {
  obs_with_noise <- sim$obs_with_noise
}
obs_with_noise_only_R <- 
  obs_with_noise %>% select(t, R)

# Visualization
plots <- plotting_simulated_data_lsoda(
  model = model,
  sim = sim,
  latency_rate = lambda,
  recovery_rate = gamma,
  fatality_rate = eta,
  log = TRUE)

(simulated_beta <- plots$simulated_beta)
(simulated_R <- plots$simulated_R)
(simulated_compartments <- plots$simulated_compartments)
(simulated_compartments_except_S <- plots$simulated_compartments_except_S)
```

#### Perform inference

```{r, fig.width=8, fig.height=6}
# ---------
# Inference
# ---------

l <- 15 # lengthscale
noise_wiener_X <- 10 # noise of Wiener process associated with X
noise_wiener_U <- 0.01 # noise of Wiener process associated with U
beta0 = df_beta$beta[1] # starting transmission rate
beta0prime <- 0 # starting 1st derivative of transmission rate
jit <- 1e-5 # value for jitter on innovation covariance
obs_to_use <- obs_with_noise # choose if obs, obs_with_noise,        
                             # obs_with_noise_only_R

# Initialize
initial_params <-
    initialization(model = model, obs = obs_to_use,
                   beta0 = beta0, beta0prime = beta0prime,
                   lambda = lambda, gamma = gamma, eta = eta,
                   l = l, scale = 1, noise_obs = noise_obs,
                   noise_X = sqrt(noise_obs), noise_U = 0.2,
                   noise_wiener_X = noise_wiener_X, 
                   noise_wiener_U = noise_wiener_U,
                   pop = pop,
                   start_S = NULL, start_E = NULL, 
                   start_I = NULL, start_R = NULL,
                   start_D = NULL)

# Generate time grids for inference
grids <- generate_grid(obs, num_points_between = 0)

# Run inference
inference_results <- inference(model = model, 
                               grids = grids, 
                               obs = obs_to_use, 
                               jit = jit, 
                               initial_params = initial_params)

# Process data for scoring and visualization
processed_data <- process_data(inference_results = inference_results,
                               grids = grids,
                               model = model,
                               pop = pop, 
                               lambda = lambda, 
                               gamma = gamma, 
                               eta = eta)
U_plot <- processed_data$U_plot
X_plot <- processed_data$X_plot
R_plot <- processed_data$R_plot
cond_plot <- processed_data$cond_plot

# Compute and display scores
list_of_scores <- 
    compute_scores_and_table(U_plot = U_plot, df_beta = df_beta)
(scores_table <- list_of_scores$scores_table)

# Plot compartment counts inferred from simulated data
(compartments <- 
  plot_compartments(model = model,
     obs = obs, 
     obs_with_noise = obs_with_noise, # if available, otherwise set NULL
     X_plot = X_plot))

# Plot all but S compartment counts inferred from simulated data
(compartments_except_S <- 
  plot_compartments_except_S(
    model = model,
    obs = obs, 
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot))

# Plot compartment counts separately
plots_sep <- 
  plot_compartments_separately(
    model = model,
    obs = obs,
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot)

num_plots <- length(plots_sep)
invisible(grid_plots_sep <- grid.arrange(
    grobs = plots_sep,
    ncol = 2,
    nrow = ceiling(num_plots/2)))

# Plot transmission rate with 95% confidence interval
(transmission_rate_with_CI <- 
    plot_transmission_rate_with_CI(U_plot = U_plot, 
    df_beta = df_beta, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot reproduction number with approx. 95% confidence interval
(reproduction_number_with_CI <- 
    plot_reproduction_number_with_CI(R_plot = R_plot, 
    df_R = df_R, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot condition numbers of the innovation covariances 
# and covariance matrices
cond_plots <- 
    plot_condition_numbers(cond_plot)

number_plots <- length(cond_plots)
invisible(condition_numbers <- grid.arrange(
    grobs = cond_plots,
    ncol = 2,
    nrow = ceiling(number_plots/2)))
```

#### Perform random search 

```{r, fig.width=8, fig.height=6}
# -------------
# Random search
# -------------

if (FALSE) { # set TRUE to perform random search
  seed <- 5
  num_param_sets <- 1000 # number of parameter sets to sample
  
  seq_l <- seq(1, 100, by = 1)
  seq_wiener_X <- c(0.001, 0.01, 0.1, 1, 10, 100)
  seq_wiener_U <- seq(0.001, 1, by = 0.01)
  seq_beta0prime <- c(-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1)
  seq_jit <- c(1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1, 10)
  
  results_summary <- 
    run_random_search(
      model = model, obs_to_use = obs_to_use, df_beta = df_beta, 
      noise_obs = noise_obs, 
      lambda = lambda, gamma = gamma, eta = eta, pop = pop, 
      beta0 = beta0, 
      seed = seed, num_param_sets = num_param_sets, 
      seq_l = seq_l, 
      seq_wiener_X = seq_wiener_X, 
      seq_wiener_U = seq_wiener_U, 
      seq_beta0prime = seq_beta0prime,
      seq_jit = seq_jit
  )
}

# Number of warnings encountered: 0
# Duration of the whole workflow: 101.007 sec elapsed

# Plot the mean scores for all hyperparameter sets explored
plots_scores <- plot_scores(
  results_summary, 
  aggregate = FALSE # if TRUE, plots reflect aggregated scores
)
invisible(grid_of_mean_plots <- grid.arrange(
  grobs = plots_scores$mean_plots,
  ncol = 2, 
  nrow = 3))
plots_scores_agg <- plot_scores(
  results_summary, 
  aggregate = TRUE # if TRUE, plots reflect aggregated scores
)
invisible(grid_of_mean_plots_agg <- grid.arrange(
  grobs = plots_scores_agg$mean_plots,
  ncol = 2, 
  nrow = 3))

# Generate a table displaying the best mean CRPS, NLPD, and SPE
best_parameters <- find_best_hyperparameters(results_summary)
(best_params_table <- best_parameters$best_params_table)

# Plot the scores (CRPS, NLPD, SPE) for each hyperparameter set
# that performed best in one of the mean scores (CRPS, NLPD, SPE).
best_scores_output <- 
  scores_of_best_params(
    best_parameters = best_parameters, 
    model = model, 
    obs_to_use = obs_to_use, 
    df_beta = df_beta, 
    noise_obs = noise_obs, 
    lambda = lambda, gamma = gamma, eta = eta, 
    pop = pop, 
    seed = seed)
invisible(best_scores_plot <- grid.arrange(
  grobs = best_scores_output$best_scores_plot,
  ncol = 1, 
  nrow = 3))

# Note that the random search runs even if errors are raised. 
# The number of errors is given at the end of the search.
```




#-------------------------------------------------------------------------------

## Simulation B (simB)

Giving only R compartment to observe.

#### Simulate data

```{r, fig.width=8, fig.height=6}
# ------------------------
# Simulation of a data set
# ------------------------

model <- 'SEIR' # model to be simulated 
                # ('SEIRD' or 'SEIR' available)

steps <- 1 # steps for time grid
max_time <- 30 # max time for time grid

lambda <- 1/(2.6) # latency rate, ref value 1/(2.6)
gamma <- 1/(2.6) # recovery rate, ref value 1/(2.6)
if (model == 'SEIRD') {
  eta <- 0.024*(1/15) # fatality rate, ref value 0.024*(1/15)
} else if (model == 'SEIR') {
  eta <- 0
}

beta <- function(t){2*cos(t/30)-1} # function for transmission rate

# Starting compartment counts
if (model == 'SEIRD') {
  xstart <- c(S = 499980, E = 5, I = 5, R = 5, D = 5)
} else if (model == 'SEIR') {
  xstart <- c(S = 499985, E = 5, I = 5, R = 5)
}
pop <- sum(xstart)

noise_obs <- 10 # noise to add on the data
            # set > 0 to avoid numerical instabilities
seed <- 5 # any integer, for reproducibility 
          # (set NA for no seed)

# Data simulation
sim <- simulate_data_LSODA(
    model = model,
    noise = noise_obs,
    seed = seed,
    steps = steps,
    max_time = max_time,
    lambda = lambda, gamma = gamma, eta = eta,
    pop = pop, 
    beta = beta,
    xstart = xstart)

# Get simulated data sets
obs <- sim$obs
df_beta <- sim$df_beta
df_R <- sim$df_R
if (noise_obs > 0) {
  obs_with_noise <- sim$obs_with_noise
}
obs_with_noise_only_R <- 
  obs_with_noise %>% select(t, R)

# Visualization
plots <- plotting_simulated_data_lsoda(
  model = model,
  sim = sim,
  latency_rate = lambda,
  recovery_rate = gamma,
  fatality_rate = eta,
  log = TRUE)

(simulated_beta <- plots$simulated_beta)
(simulated_R <- plots$simulated_R)
(simulated_compartments <- plots$simulated_compartments)
(simulated_compartments_except_S <- plots$simulated_compartments_except_S)
```

#### Perform inference

```{r, fig.width=8, fig.height=6}
# ---------
# Inference
# ---------

l <- 15 # lengthscale
noise_wiener_X <- 10 # noise of Wiener process associated with X
noise_wiener_U <- 0.5 # noise of Wiener process associated with U
beta0 = df_beta$beta[1] # starting transmission rate
beta0prime <- 0 # starting 1st derivative of transmission rate
jit <- 1e-5 # value for jitter on innovation covariance
obs_to_use <- obs_with_noise_only_R # choose if obs, obs_with_noise,        
                                    # obs_with_noise_only_R

# Initialize
initial_params <-
    initialization(model = model, obs = obs_to_use,
                   beta0 = beta0, beta0prime = beta0prime,
                   lambda = lambda, gamma = gamma, eta = eta,
                   l = l, scale = 1, noise_obs = noise_obs,
                   noise_X = sqrt(noise_obs), noise_U = 0.2,
                   noise_wiener_X = noise_wiener_X, 
                   noise_wiener_U = noise_wiener_U,
                   pop = pop,
                   start_S = NULL, start_E = NULL, 
                   start_I = NULL, start_R = NULL,
                   start_D = NULL)

# Generate time grids for inference
grids <- generate_grid(obs, num_points_between = 0)

# Run inference
inference_results <- inference(model = model, 
                               grids = grids, 
                               obs = obs_to_use, 
                               jit = jit, 
                               initial_params = initial_params)

# Process data for scoring and visualization
processed_data <- process_data(inference_results = inference_results,
                               grids = grids,
                               model = model,
                               pop = pop, 
                               lambda = lambda, 
                               gamma = gamma, 
                               eta = eta)
U_plot <- processed_data$U_plot
X_plot <- processed_data$X_plot
R_plot <- processed_data$R_plot
cond_plot <- processed_data$cond_plot

# Compute and display scores
list_of_scores <- 
    compute_scores_and_table(U_plot = U_plot, df_beta = df_beta)
(scores_table <- list_of_scores$scores_table)

# Plot compartment counts inferred from simulated data
(compartments <- 
  plot_compartments(model = model,
     obs = obs, 
     obs_with_noise = obs_with_noise, # if available, otherwise set NULL
     X_plot = X_plot))

# Plot all but S compartment counts inferred from simulated data
(compartments_except_S <- 
  plot_compartments_except_S(
    model = model,
    obs = obs, 
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot))

# Plot compartment counts separately
plots_sep <- 
  plot_compartments_separately(
    model = model,
    obs = obs,
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot)

num_plots <- length(plots_sep)
invisible(grid_plots_sep <- grid.arrange(
    grobs = plots_sep,
    ncol = 2,
    nrow = ceiling(num_plots/2)))

# Plot transmission rate with 95% confidence interval
(transmission_rate_with_CI <- 
    plot_transmission_rate_with_CI(U_plot = U_plot, 
    df_beta = df_beta, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot reproduction number with approx. 95% confidence interval
(reproduction_number_with_CI <- 
    plot_reproduction_number_with_CI(R_plot = R_plot, 
    df_R = df_R, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot condition numbers of the innovation covariances 
# and covariance matrices
cond_plots <- 
    plot_condition_numbers(cond_plot)

number_plots <- length(cond_plots)
invisible(condition_numbers <- grid.arrange(
    grobs = cond_plots,
    ncol = 2,
    nrow = ceiling(number_plots/2)))
```

#### Perform random search 

```{r, fig.width=8, fig.height=6}
# -------------
# Random search
# -------------

if (FALSE) { # set TRUE to perform random search
  seed <- 5
  num_param_sets <- 1000 # number of parameter sets to sample
  
  seq_l <- seq(1, 100, by = 1)
  seq_wiener_X <- c(0.001, 0.01, 0.1, 1, 10, 100)
  seq_wiener_U <- seq(0.001, 1, by = 0.01)
  seq_beta0prime <- c(-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1)
  seq_jit <- c(1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1, 10)
  
  results_summary <- 
    run_random_search(
      model = model, obs_to_use = obs_to_use, df_beta = df_beta, 
      noise_obs = noise_obs, 
      lambda = lambda, gamma = gamma, eta = eta, pop = pop, 
      beta0 = beta0, 
      seed = seed, num_param_sets = num_param_sets, 
      seq_l = seq_l, 
      seq_wiener_X = seq_wiener_X, 
      seq_wiener_U = seq_wiener_U, 
      seq_beta0prime = seq_beta0prime,
      seq_jit = seq_jit
  )
}

# Number of warnings encountered: 0
# Duration of the whole workflow: 81.442 sec elapsed

# Plot the mean scores for all hyperparameter sets explored
plots_scores <- plot_scores(
  results_summary, 
  aggregate = FALSE # if TRUE, plots reflect aggregated scores
)
invisible(grid_of_mean_plots <- grid.arrange(
  grobs = plots_scores$mean_plots,
  ncol = 2, 
  nrow = 3))
plots_scores_agg <- plot_scores(
  results_summary, 
  aggregate = TRUE # if TRUE, plots reflect aggregated scores
)
invisible(grid_of_mean_plots_agg <- grid.arrange(
  grobs = plots_scores_agg$mean_plots,
  ncol = 2, 
  nrow = 3))

# Generate a table displaying the best mean CRPS, NLPD, and SPE
best_parameters <- find_best_hyperparameters(results_summary)
(best_params_table <- best_parameters$best_params_table)

# Plot the scores (CRPS, NLPD, SPE) for each hyperparameter set
# that performed best in one of the mean scores (CRPS, NLPD, SPE).
best_scores_output <- 
  scores_of_best_params(
    best_parameters = best_parameters, 
    model = model, 
    obs_to_use = obs_to_use, 
    df_beta = df_beta, 
    noise_obs = noise_obs, 
    lambda = lambda, gamma = gamma, eta = eta, 
    pop = pop, 
    seed = seed)
invisible(best_scores_plot <- grid.arrange(
  grobs = best_scores_output$best_scores_plot,
  ncol = 1, 
  nrow = 3))

# Note that the random search runs even if errors are raised. 
# The number of errors is given at the end of the search.
```


#-------------------------------------------------------------------------------

## Simulation C (simC)

More days, different transmission rate.

#### Simulate data

```{r, fig.width=8, fig.height=6}
# ------------------------
# Simulation of a data set
# ------------------------

model <- 'SEIR' # model to be simulated 
                # ('SEIRD' or 'SEIR' available)

steps <- 1 # steps for time grid
max_time <- 100 # max time for time grid

lambda <- 1/(2.6) # latency rate, ref value 1/(2.6)
gamma <- 1/(2.6) # recovery rate, ref value 1/(2.6)
if (model == 'SEIRD') {
  eta <- 0.024*(1/15) # fatality rate, ref value 0.024*(1/15)
} else if (model == 'SEIR') {
  eta <- 0
}

beta <- function(t){0.2*cos(t/10)+0.6} # function for transmission rate

# Starting compartment counts
if (model == 'SEIRD') {
  xstart <- c(S = 499980, E = 5, I = 5, R = 5, D = 5)
} else if (model == 'SEIR') {
  xstart <- c(S = 499985, E = 5, I = 5, R = 5)
}
pop <- sum(xstart)

noise_obs <- 10 # noise to add on the data
            # set > 0 to avoid numerical instabilities
seed <- 5 # any integer, for reproducibility 
          # (set NA for no seed)

# Data simulation
sim <- simulate_data_LSODA(
    model = model,
    noise = noise_obs,
    seed = seed,
    steps = steps,
    max_time = max_time,
    lambda = lambda, gamma = gamma, eta = eta,
    pop = pop, 
    beta = beta,
    xstart = xstart)

# Get simulated data sets
obs <- sim$obs
df_beta <- sim$df_beta
df_R <- sim$df_R
if (noise_obs > 0) {
  obs_with_noise <- sim$obs_with_noise
}
obs_with_noise_only_R <- 
  obs_with_noise %>% select(t, R)

# Visualization
plots <- plotting_simulated_data_lsoda(
  model = model,
  sim = sim,
  latency_rate = lambda,
  recovery_rate = gamma,
  fatality_rate = eta,
  log = TRUE)

(simulated_beta <- plots$simulated_beta)
(simulated_R <- plots$simulated_R)
(simulated_compartments <- plots$simulated_compartments)
(simulated_compartments_except_S <- plots$simulated_compartments_except_S)
```

#### Perform inference

```{r, fig.width=8, fig.height=6}
# ---------
# Inference
# ---------

l <- 30 # lengthscale
noise_wiener_X <- 1 # noise of Wiener process associated with X
noise_wiener_U <- 0.5 # noise of Wiener process associated with U
beta0 = df_beta$beta[1] # starting transmission rate
beta0prime <- 0 # starting 1st derivative of transmission rate
jit <- 1e-1 # value for jitter on innovation covariance
obs_to_use <- obs_with_noise # choose if obs, obs_with_noise,        
                             # obs_with_noise_only_R

# Initialize
initial_params <-
    initialization(model = model, obs = obs_to_use,
                   beta0 = beta0, beta0prime = beta0prime,
                   lambda = lambda, gamma = gamma, eta = eta,
                   l = l, scale = 1, noise_obs = noise_obs,
                   noise_X = sqrt(noise_obs), noise_U = 0.2,
                   noise_wiener_X = noise_wiener_X, 
                   noise_wiener_U = noise_wiener_U,
                   pop = pop,
                   start_S = NULL, start_E = NULL, 
                   start_I = NULL, start_R = NULL,
                   start_D = NULL)

# Generate time grids for inference
grids <- generate_grid(obs, num_points_between = 0)

# Run inference
inference_results <- inference(model = model, 
                               grids = grids, 
                               obs = obs_to_use, 
                               jit = jit, 
                               initial_params = initial_params)

# Process data for scoring and visualization
processed_data <- process_data(inference_results = inference_results,
                               grids = grids,
                               model = model,
                               pop = pop, 
                               lambda = lambda, 
                               gamma = gamma, 
                               eta = eta)
U_plot <- processed_data$U_plot
X_plot <- processed_data$X_plot
R_plot <- processed_data$R_plot
cond_plot <- processed_data$cond_plot

# Compute and display scores
list_of_scores <- 
    compute_scores_and_table(U_plot = U_plot, df_beta = df_beta)
(scores_table <- list_of_scores$scores_table)

# Plot compartment counts inferred from simulated data
(compartments <- 
  plot_compartments(model = model,
     obs = obs, 
     obs_with_noise = obs_with_noise, # if available, otherwise set NULL
     X_plot = X_plot))

# Plot all but S compartment counts inferred from simulated data
(compartments_except_S <- 
  plot_compartments_except_S(
    model = model,
    obs = obs, 
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot))

# Plot compartment counts separately
plots_sep <- 
  plot_compartments_separately(
    model = model,
    obs = obs,
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot)

num_plots <- length(plots_sep)
invisible(grid_plots_sep <- grid.arrange(
    grobs = plots_sep,
    ncol = 2,
    nrow = ceiling(num_plots/2)))

# Plot transmission rate with 95% confidence interval
(transmission_rate_with_CI <- 
    plot_transmission_rate_with_CI(U_plot = U_plot, 
    df_beta = df_beta, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot reproduction number with approx. 95% confidence interval
(reproduction_number_with_CI <- 
    plot_reproduction_number_with_CI(R_plot = R_plot, 
    df_R = df_R, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot condition numbers of the innovation covariances 
# and covariance matrices
cond_plots <- 
    plot_condition_numbers(cond_plot)

number_plots <- length(cond_plots)
invisible(condition_numbers <- grid.arrange(
    grobs = cond_plots,
    ncol = 2,
    nrow = ceiling(number_plots/2)))
```

#### Perform random search 

```{r, fig.width=8, fig.height=6}
# -------------
# Random search
# -------------

if (FALSE) { # set TRUE to perform random search
  seed <- 5
  num_param_sets <- 1000 # number of parameter sets to sample
  
  seq_l <- seq(1, 100, by = 1)
  seq_wiener_X <- c(0.001, 0.01, 0.1, 1, 10, 100)
  seq_wiener_U <- seq(0.001, 1, by = 0.01)
  seq_beta0prime <- c(-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1)
  seq_jit <- c(1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1, 10)
  
  results_summary <- 
    run_random_search(
      model = model, obs_to_use = obs_to_use, df_beta = df_beta, 
      noise_obs = noise_obs, 
      lambda = lambda, gamma = gamma, eta = eta, pop = pop, 
      beta0 = beta0, 
      seed = seed, num_param_sets = num_param_sets, 
      seq_l = seq_l, 
      seq_wiener_X = seq_wiener_X, 
      seq_wiener_U = seq_wiener_U, 
      seq_beta0prime = seq_beta0prime,
      seq_jit = seq_jit
  )
}

# Number of warnings encountered: 0
# Duration of the whole workflow: 394.687 sec elapsed

# Plot the mean scores for all hyperparameter sets explored
plots_scores <- plot_scores(
  results_summary, 
  aggregate = FALSE # if TRUE, plots reflect aggregated scores
)
invisible(grid_of_mean_plots <- grid.arrange(
  grobs = plots_scores$mean_plots,
  ncol = 2, 
  nrow = 3))
plots_scores_agg <- plot_scores(
  results_summary, 
  aggregate = TRUE # if TRUE, plots reflect aggregated scores
)
invisible(grid_of_mean_plots_agg <- grid.arrange(
  grobs = plots_scores_agg$mean_plots,
  ncol = 2, 
  nrow = 3))

# Generate a table displaying the best mean CRPS, NLPD, and SPE
best_parameters <- find_best_hyperparameters(results_summary)
(best_params_table <- best_parameters$best_params_table)

# Plot the scores (CRPS, NLPD, SPE) for each hyperparameter set
# that performed best in one of the mean scores (CRPS, NLPD, SPE).
best_scores_output <- 
  scores_of_best_params(
    best_parameters = best_parameters, 
    model = model, 
    obs_to_use = obs_to_use, 
    df_beta = df_beta, 
    noise_obs = noise_obs, 
    lambda = lambda, gamma = gamma, eta = eta, 
    pop = pop, 
    seed = seed)
invisible(best_scores_plot <- grid.arrange(
  grobs = best_scores_output$best_scores_plot,
  ncol = 1, 
  nrow = 3))

# Note that the random search runs even if errors are raised. 
# The number of errors is given at the end of the search.
```



#-------------------------------------------------------------------------------

## Simulation D (simD)

Same as simC but giving access only to R.

#### Simulate data

```{r, fig.width=8, fig.height=6}
# ------------------------
# Simulation of a data set
# ------------------------

model <- 'SEIR' # model to be simulated 
                # ('SEIRD' or 'SEIR' available)

steps <- 1 # steps for time grid
max_time <- 100 # max time for time grid

lambda <- 1/(2.6) # latency rate, ref value 1/(2.6)
gamma <- 1/(2.6) # recovery rate, ref value 1/(2.6)
if (model == 'SEIRD') {
  eta <- 0.024*(1/15) # fatality rate, ref value 0.024*(1/15)
} else if (model == 'SEIR') {
  eta <- 0
}

beta <- function(t){0.2*cos(t/10)+0.6} # function for transmission rate

# Starting compartment counts
if (model == 'SEIRD') {
  xstart <- c(S = 499980, E = 5, I = 5, R = 5, D = 5)
} else if (model == 'SEIR') {
  xstart <- c(S = 499985, E = 5, I = 5, R = 5)
}
pop <- sum(xstart)

noise_obs <- 10 # noise to add on the data
            # set > 0 to avoid numerical instabilities
seed <- 5 # any integer, for reproducibility 
          # (set NA for no seed)

# Data simulation
sim <- simulate_data_LSODA(
    model = model,
    noise = noise_obs,
    seed = seed,
    steps = steps,
    max_time = max_time,
    lambda = lambda, gamma = gamma, eta = eta,
    pop = pop, 
    beta = beta,
    xstart = xstart)

# Get simulated data sets
obs <- sim$obs
df_beta <- sim$df_beta
df_R <- sim$df_R
if (noise_obs > 0) {
  obs_with_noise <- sim$obs_with_noise
}
obs_with_noise_only_R <- 
  obs_with_noise %>% select(t, R)

# Visualization
plots <- plotting_simulated_data_lsoda(
  model = model,
  sim = sim,
  latency_rate = lambda,
  recovery_rate = gamma,
  fatality_rate = eta,
  log = TRUE)

(simulated_beta <- plots$simulated_beta)
(simulated_R <- plots$simulated_R)
(simulated_compartments <- plots$simulated_compartments)
(simulated_compartments_except_S <- plots$simulated_compartments_except_S)
```

#### Perform inference

```{r, fig.width=8, fig.height=6}
# ---------
# Inference
# ---------

l <- 30 # lengthscale
noise_wiener_X <- 1 # noise of Wiener process associated with X
noise_wiener_U <- 0.5 # noise of Wiener process associated with U
beta0 = df_beta$beta[1] # starting transmission rate
beta0prime <- 0 # starting 1st derivative of transmission rate
jit <- 1e-1 # value for jitter on innovation covariance
obs_to_use <- obs_with_noise_only_R # choose if obs, obs_with_noise,        
                             # obs_with_noise_only_R

# Initialize
initial_params <-
    initialization(model = model, obs = obs_to_use,
                   beta0 = beta0, beta0prime = beta0prime,
                   lambda = lambda, gamma = gamma, eta = eta,
                   l = l, scale = 1, noise_obs = noise_obs,
                   noise_X = sqrt(noise_obs), noise_U = 0.1,
                   noise_wiener_X = noise_wiener_X, 
                   noise_wiener_U = noise_wiener_U,
                   pop = pop,
                   start_S = NULL, start_E = NULL, 
                   start_I = NULL, start_R = NULL,
                   start_D = NULL)

# Generate time grids for inference
grids <- generate_grid(obs, num_points_between = 0)

# Run inference
inference_results <- inference(model = model, 
                               grids = grids, 
                               obs = obs_to_use, 
                               jit = jit, 
                               initial_params = initial_params)

# Process data for scoring and visualization
processed_data <- process_data(inference_results = inference_results,
                               grids = grids,
                               model = model,
                               pop = pop, 
                               lambda = lambda, 
                               gamma = gamma, 
                               eta = eta)
U_plot <- processed_data$U_plot
X_plot <- processed_data$X_plot
R_plot <- processed_data$R_plot
cond_plot <- processed_data$cond_plot

# Compute and display scores
list_of_scores <- 
    compute_scores_and_table(U_plot = U_plot, df_beta = df_beta)
(scores_table <- list_of_scores$scores_table)

# Plot compartment counts inferred from simulated data
(compartments <- 
  plot_compartments(model = model,
     obs = obs, 
     obs_with_noise = obs_with_noise, # if available, otherwise set NULL
     X_plot = X_plot))

# Plot all but S compartment counts inferred from simulated data
(compartments_except_S <- 
  plot_compartments_except_S(
    model = model,
    obs = obs, 
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot))

# Plot compartment counts separately
plots_sep <- 
  plot_compartments_separately(
    model = model,
    obs = obs,
    obs_with_noise = obs_with_noise, # if available, otherwise set NULL
    X_plot = X_plot)

num_plots <- length(plots_sep)
invisible(grid_plots_sep <- grid.arrange(
    grobs = plots_sep,
    ncol = 2,
    nrow = ceiling(num_plots/2)))

# Plot transmission rate with 95% confidence interval
(transmission_rate_with_CI <- 
    plot_transmission_rate_with_CI(U_plot = U_plot, 
    df_beta = df_beta, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot reproduction number with approx. 95% confidence interval
(reproduction_number_with_CI <- 
    plot_reproduction_number_with_CI(R_plot = R_plot, 
    df_R = df_R, # if available, otherwise set NULL
    latency_rate = lambda, 
    recovery_rate = gamma, 
    fatality_rate = eta, 
    lengthscale = l))

# Plot condition numbers of the innovation covariances 
# and covariance matrices
cond_plots <- 
    plot_condition_numbers(cond_plot)

number_plots <- length(cond_plots)
invisible(condition_numbers <- grid.arrange(
    grobs = cond_plots,
    ncol = 2,
    nrow = ceiling(number_plots/2)))
```

#### Perform random search 

```{r, fig.width=8, fig.height=6}
# -------------
# Random search
# -------------

if (TRUE) { # set TRUE to perform random search
  seed <- 5
  num_param_sets <- 100 # number of parameter sets to sample
  
  seq_l <- seq(1, 100, by = 1)
  #seq_l <- 60
  #seq_wiener_X <- c(0.001, 0.01, 0.1, 1, 10, 100)
  #seq_wiener_X <- exp(seq(-5,5,length.out=100))
  seq_wiener_X <- 0.01
  #seq_wiener_U <- seq(0.001, 1, by = 0.01)
  seq_wiener_U <- 0.2
  #seq_beta0prime <- c(-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1)
  seq_beta0prime <- 0
  #seq_jit <- c(1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1, 10)
  seq_jit <- 1e-4
  
  results_summary <- 
    run_random_search(
      model = model, obs_to_use = obs_to_use, df_beta = df_beta, 
      noise_obs = noise_obs, 
      lambda = lambda, gamma = gamma, eta = eta, pop = pop, 
      beta0 = beta0, 
      seed = seed, num_param_sets = num_param_sets, 
      seq_l = seq_l, 
      seq_wiener_X = seq_wiener_X, 
      seq_wiener_U = seq_wiener_U, 
      seq_beta0prime = seq_beta0prime,
      seq_jit = seq_jit
  )
}

# Number of warnings encountered: 
# Duration of the whole workflow: 

# Plot the mean scores for all hyperparameter sets explored
plots_scores <- plot_scores(
  results_summary, 
  aggregate = FALSE # if TRUE, plots reflect aggregated scores
)
invisible(grid_of_mean_plots <- grid.arrange(
  grobs = plots_scores$mean_plots,
  ncol = 2, 
  nrow = 3))
plots_scores_agg <- plot_scores(
  results_summary, 
  aggregate = TRUE # if TRUE, plots reflect aggregated scores
)
invisible(grid_of_mean_plots_agg <- grid.arrange(
  grobs = plots_scores_agg$mean_plots,
  ncol = 2, 
  nrow = 3))

# Generate a table displaying the best mean CRPS, NLPD, and SPE
best_parameters <- find_best_hyperparameters(results_summary)
(best_params_table <- best_parameters$best_params_table)

# Plot the scores (CRPS, NLPD, SPE) for each hyperparameter set
# that performed best in one of the mean scores (CRPS, NLPD, SPE).
best_scores_output <- 
  scores_of_best_params(
    best_parameters = best_parameters, 
    model = model, 
    obs_to_use = obs_to_use, 
    df_beta = df_beta, 
    noise_obs = noise_obs, 
    lambda = lambda, gamma = gamma, eta = eta, 
    pop = pop, 
    seed = seed)
invisible(best_scores_plot <- grid.arrange(
  grobs = best_scores_output$best_scores_plot,
  ncol = 1, 
  nrow = 3))

# Note that the random search runs even if errors are raised. 
# The number of errors is given at the end of the search.
```


# -----------------------------------------------------------------------------

## Store data

```{r}
# -------------
# Store results
# -------------

# Every argument except directory is optional. 

directory_save <- '~/Documents/GitHub/proboder/Results/'
folder_name <- 'simA'
random_search <- FALSE # set TRUE to save random search results, else FALSE

if (!random_search) { # Set TRUE to save
  save_processed_data(
    directory = directory_save,
    folder_name = folder_name,
    model = model,
    # Data
    inference_results = inference_results, 
    processed_data = processed_data, 
    # Plots
    simulated_compartments = simulated_compartments, 
    simulated_compartments_except_S = simulated_compartments_except_S,
    simulated_beta = simulated_beta,
    simulated_R = simulated_R,
    compartments = compartments,
    compartments_except_S = compartments_except_S,
    transmission_rate_with_CI = transmission_rate_with_CI,
    reproduction_number_with_CI = reproduction_number_with_CI,
    grid_plots_sep = grid_plots_sep,
    condition_numbers = condition_numbers,
    scores_table = scores_table)
}

if (random_search) { # Set TRUE to save
  save_processed_data(
    directory = directory_save,
    folder_name = folder_name,
    model = model,
    # Random search
    grid_of_mean_plots = grid_of_mean_plots,
    best_params_table = best_params_table,
    best_scores_plot = best_scores_plot,
    grid_of_mean_plots_agg = grid_of_mean_plots_agg)
}

# To store a table as a png file, use the manual export option from the viewer.
```